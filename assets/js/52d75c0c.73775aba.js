"use strict";(self.webpackChunkcasual_simulation=self.webpackChunkcasual_simulation||[]).push([[506],{979:(e,t,n)=>{n.d(t,{Ey:()=>q,yx:()=>R,H_:()=>v});var r=n(7378),i=n(4183),a=n(3456),o=n(600),s=n(9012),c=n(6106);class l extends r.Component{constructor(e){super(e),this.state={hasError:!1}}static getDerivedStateFromError(e){return{hasError:!0,error:e}}componentDidCatch(e,t){const n=`[${this.props.reflection.name}] ${e}`;if(!this.props.root)throw n;console.error(n)}render(){return this.state.hasError?(0,c.jsxs)("h1",{children:["[",this.props.reflection.name,"] ",this.state.error]}):this.props.children}}var d=n(300),m=n(7847),u=n(3675),h=n(2759),p=n(975);function g(e){void 0===e&&(e={});const t=e.references;return e=>{(0,p.YR)(e,"link",(e=>{if(e.url.startsWith("tags:")){const t=e.url.slice(5);t.startsWith("@")?e.url=(0,d.Ay)("listen-tags")+f(t.slice(1)):e.url=(0,d.Ay)("tags")+f(t)}else if(e.url.startsWith("ref:")){const n=e.url.slice(4),r=t[n];e.url=(0,d.Ay)(r)+"#"+n}else if(e.url.startsWith("glossary:")){const t=e.url.slice(9);e.url=(0,d.Ay)("glossary")+"#"+x(t)}else if(e.url.startsWith("page:")){const[t,n]=e.url.slice(5).split("#");e.url=(0,d.Ay)(t)+"#"+n}}))}}function f(e){return"#"+x(e)}function x(e){return e.replace(/[\.\(\)\@\[\]]/g,"").toLowerCase()}function y(e){return void 0===e&&(e={}),e=>{e&&e.children&&e.children.length>0&&"paragraph"===e.children[0].type&&(e.children=e.children[0].children.concat(e.children.slice(1)))}}const k={Property:["type"],reflection:["declaration"],"Type literal":["children","signatures"],"Call signature":["parameters","comment","type"]};function j(e,t,n){void 0===n&&(n=null),function(e,t,n){void 0===n&&(n=null);let r=k[e.kindString??e.type]||[];for(let i of r){let r=e[i];if(Array.isArray(r))for(let e of r)e&&t(e,n,i);else r&&t(r,n,i)}}(e,((e,n,r)=>{t(e,n,r),j(e,t,e)}))}let b={};function v(e){b=e}const S=["first","second","third","fourth","fifth"];function T(e,t){return`${e.name}-${t.name}`}function w(e,t){const n=T(e,t);let r;var i;return r="Constructor"===t.kindString||"Method"===t.kindString?$(t.signatures[0]):"Accessor"===t.kindString?`${(i=t).name}: ${J(i.getSignature[0].type)}`:L(t),r=`<code>${r}</code>`,{value:r,id:n,level:3}}function R(e){let t=[],{properties:n,constructors:r,methods:i}=function(e){let t=[],n=[],r=[];if(!e)return{properties:t,constructors:n,methods:r};for(let i of e)i.flags.isPrivate||("Property"===i.kindString||"Accessor"===i.kindString?t.push(i):"Constructor"===i.kindString?n.push(i):"Method"===i.kindString&&r.push(i));return{properties:t,constructors:n,methods:r}}(e.children);return n.length>0&&t.push(...n.map((t=>w(e,t)))),r.length>0&&t.push(...r.map((t=>w(e,t)))),i.length>0&&t.push(...i.map((t=>w(e,t)))),t}function q(e){const t=e.reflection;if(!t)throw new Error("Unable to find "+e.name+"!");const n=function(e){return(0,s.U)(e,(e=>"Property"===e.kindString||"Accessor"===e.kindString?0:"Constructor"===e.kindString?1:2)).filter((e=>!e.flags.isPrivate))}(t.children??[]);return(0,c.jsx)(l,{reflection:t,root:!0,children:(0,c.jsxs)("div",{className:"api",children:[(0,c.jsx)(P,{reflection:t,references:e.references}),t.indexSignature?(0,c.jsx)(A,{reflection:t,index:t.indexSignature,references:e.references}):"",t.references?(0,c.jsx)(N,{prop:t,references:e.references}):"",n.map((n=>(0,c.jsx)(C,{member:n,link:T(t,n),references:e.references},n.name)))]})})}function A(e){let{reflection:t,index:n,references:r}=e;const a=n.parameters[0];return(0,c.jsxs)("div",{children:[(0,c.jsx)(i.A,{as:"h3",id:`${t.name}-_index`,children:"Index Signature"}),(0,c.jsx)(P,{reflection:n,references:r}),(0,c.jsx)("pre",{children:(0,c.jsxs)("code",{children:["[",a.name,": ",(0,c.jsx)(_,{type:a.type,references:r}),"]: ",(0,c.jsx)(_,{type:n.type,references:r})]})}),(0,c.jsx)(z,{member:n})]})}function P(e){let{reflection:t,references:n}=e;return(0,c.jsx)("div",{children:(0,c.jsx)(D,{comment:t.comment,references:n})})}function C(e){let t;return t="Property"===e.member.kindString?function(e){let t,n=e.member,r="";n.references?(r=(0,c.jsx)(Q,{prop:n,references:e.references}),t=(0,c.jsx)(c.Fragment,{children:n.typeReference})):"reflection"===n.type.type&&n.typeText&&n.typeReference?(t=(0,c.jsx)(c.Fragment,{children:n.typeReference}),r=(0,c.jsx)(a.A,{language:"typescript",children:n.typeText})):t=(0,c.jsx)(_,{type:e.member.type,references:e.references});!r&&n.typeText&&n.typeReference&&(r=(0,c.jsx)(a.A,{language:"typescript",children:n.typeText}));const o=te(n);ne(n);return(0,c.jsxs)("div",{children:[(0,c.jsx)(i.A,{as:"h3",id:e.link,children:(0,c.jsxs)("code",{children:[o,e.member.flags.isOptional?"?":"",": ",t]})}),(0,c.jsx)(P,{reflection:e.member,references:e.references}),r]})}(e):"Constructor"===e.member.kindString?function(e){const t=te(e.member);return(0,c.jsx)("div",{children:(0,c.jsx)(M,{func:e.member,name:t,sig:e.member.signatures[0],link:e.link,references:e.references})})}(e):"Method"===e.member.kindString?function(e){const t=te(e.member);return(0,c.jsx)("div",{children:(0,c.jsx)(M,{func:e.member,name:t,sig:e.member.signatures[0],link:e.link,references:e.references})})}(e):"Accessor"===e.member.kindString?function(e){return(0,c.jsxs)("div",{children:[(0,c.jsx)(i.A,{as:"h3",id:e.link,children:(0,c.jsxs)("code",{children:[e.member.name,": ",(0,c.jsx)(_,{type:e.member.getSignature[0].type,references:e.references})]})}),(0,c.jsx)("p",{children:e.member.getSignature[0].comment?.shortText})]})}(e):"Not found "+e.member.kindString,(0,c.jsx)(l,{reflection:e.member,children:(0,c.jsx)("div",{children:t})})}function N(e){let{prop:t,references:n}=e;const r=ne(t);return(0,c.jsxs)("div",{children:[(0,c.jsx)(i.A,{as:"h3",id:`${r}-extra-functions`,children:"Extra Functions"}),(0,c.jsx)("p",{children:"The extra functions that are available on this type."}),(0,c.jsxs)(o.A,{children:[(0,c.jsx)("p",{children:"See the following functions for more information:"}),(0,c.jsx)(I,{children:t.references,references:n})]})]})}function Q(e){let{prop:t,references:n}=e;return(0,c.jsxs)(o.A,{children:[(0,c.jsx)("p",{children:"See the following functions for more information:"}),(0,c.jsx)(I,{children:t.references,references:n})]})}function M(e){let{func:t,sig:n,link:r,name:a,references:o}=e;n||console.log(a,t);const s=n.parameters||[];return(0,c.jsxs)("div",{children:[(0,c.jsx)(i.A,{as:"h3",id:r,children:(0,c.jsx)(O,{func:t,sig:n,name:a,references:o})}),(0,c.jsx)(V,{sig:n,references:o}),s.length>0?(0,c.jsx)("div",{children:s.map(((e,t)=>(0,c.jsx)(E,{param:e,index:t,references:o},e.name)))}):"",(0,c.jsx)(z,{member:n})]})}function V(e){let{sig:t,references:n}=e;return(0,c.jsx)(D,{comment:t.comment,references:n})}function D(e){let{comment:t,references:n}=e;return(0,c.jsx)(I,{references:n,children:F(t)})}function I(e){let{children:t,remarkPlugins:n,rehypePlugins:r,references:i}=e;return(0,c.jsx)(u.o,{remarkPlugins:[[g,{references:i}],...n||[]],rehypePlugins:[h.A,...r||[]],children:t})}function F(e){let t="";return e&&(t+=e.shortText,e.text&&(t+="\n\n"+e.text)),t}function O(e){let{func:t,sig:n,name:r,references:i}=e;const a=n.parameters||[];let o="";return"Get signature"!==t.kindString&&(o=(0,c.jsxs)(c.Fragment,{children:["(",a.map(((e,t)=>(0,c.jsxs)("span",{children:[t>0?", ":"",e.flags.isRest?"...":"",e.name,e.flags.isOptional?"?":"",": ",(0,c.jsx)(_,{type:e.type,references:i})]},e.name))),")"]})),(0,c.jsxs)("code",{children:[(t.flags.isStatic?"static ":"")+(r||n.name),o,": ",(0,c.jsx)(_,{type:n.type,references:i})]})}function $(e,t){void 0===t&&(t=e.name);const n=e.parameters||[];let r="";return"Get signature"!==e.kindString&&(r=`(${n.map(((e,t)=>(e.flags.isRest?"...":"")+e.name)).join(", ")})`),`${t}${r}: ${J(e.type)}`}function E(e){let t,{param:n,index:r,references:i}=e;return t=n.flags.isRest&&n.type.elementType?0===r?(0,c.jsxs)("p",{children:[(0,c.jsx)("strong",{children:"Each parameter"})," is a ",(0,c.jsx)(_,{type:n.type.elementType,references:i})," and are ",(0,c.jsx)(Z,{param:n,isRest:!0,references:i})]}):(0,c.jsxs)("p",{children:[(0,c.jsx)("strong",{children:"Each other parameter"})," is a ",(0,c.jsx)(_,{type:n.type.elementType,references:i})," and are ",(0,c.jsx)(Z,{param:n,isRest:!0,references:i})]}):(0,c.jsxs)("p",{children:["The ",(0,c.jsxs)("strong",{children:[X(r)," parameter"]})," is",n.flags.isOptional?" optional and is":""," a ",(0,c.jsx)(_,{type:n.type,references:i})," and ",(0,c.jsx)(Z,{param:n,references:i})]}),t}function z(e){let{member:t}=e;if(!t.comment?.tags)return"";const n=t.comment.tags.filter((e=>"example"===e.tag));return n.length>0?(0,c.jsxs)("div",{children:[(0,c.jsx)("h4",{children:"Examples"}),n.map(((e,t)=>(0,c.jsx)(W,{example:e},t)))]}):""}function W(e){let{example:t}=e;const n=t.text,r=n.indexOf("\n"),i=n.substring(0,r),o=n.substring(r+1);return(0,c.jsx)(a.A,{language:"typescript",title:i.trim(),children:o.trim()})}function X(e){return S[e]}function L(e,t){let n;return void 0===t&&(t=e.name),n=e.typeReference?e.typeReference:J(e.type),`${t}${e.flags.isOptional?"?":""}: ${n}`}function Z(e){let{param:t,isRest:n,references:r}=e;return(0,c.jsx)(I,{remarkPlugins:[y],references:r,children:Y(t,n)})}function Y(e,t){let n=F(e.comment);return n?(n=n.slice(0,1).toLowerCase()+n.slice(1),n.startsWith("the")&&!t&&(n="is "+n),n):""}function _(e){let{type:t,references:n,isInUnionOrArray:i}=e;if("intrinsic"===t.type)return(0,c.jsx)("span",{children:t.name});if(t.name){if("Promise"===t.name&&"Promise"===t.qualifiedName&&t.typeArguments&&1===t.typeArguments.length)return(0,c.jsxs)(c.Fragment,{children:["Promise<",(0,c.jsx)(_,{type:t.typeArguments[0],references:n}),">"]});if("Partial"===t.name&&"Partial"===t.qualifiedName&&t.typeArguments&&1===t.typeArguments.length)return(0,c.jsxs)(c.Fragment,{children:[(0,c.jsx)("a",{href:"https://www.typescriptlang.org/docs/handbook/utility-types.html#partialtype",children:"Partial"}),"<",(0,c.jsx)(_,{type:t.typeArguments[0],references:n}),">"]});let e=`#${t.name}`;const r=t.id?n?.[`id-${t.id}`]:null;if(r){const t=n?.[r];t&&(e=(0,d.Ay)(t)+`#${r}`)}else t.id?console.log("Missing reference for",t.id,t.name,t,"it is likely that the type does not have a @docid or @docname comment"):console.log("Missing reference for",t,"it is likely that the type is not exported from the entry");return(0,c.jsx)(m.A,{href:e,children:t.name})}if("union"===t.type)return(0,c.jsxs)("span",{children:["(",t.types.map(((e,t)=>(0,c.jsxs)(r.Fragment,{children:[t>0?" | ":"",(0,c.jsx)(_,{type:e,references:n,isInUnionOrArray:!0})]},t))),")"]});if("array"===t.type)return(0,c.jsxs)(c.Fragment,{children:[(0,c.jsx)(_,{type:t.elementType,references:n,isInUnionOrArray:!0}),"[]"]});if("literal"===t.type)return"string"==typeof t.value?(0,c.jsxs)("span",{children:['"',t.value,'"']}):"number"==typeof t.value?(0,c.jsx)("span",{children:t.value}):"boolean"==typeof t.value?(0,c.jsx)("span",{children:t.value?"true":"false"}):void 0===t.value?(0,c.jsx)("span",{children:"undefined"}):null===t.value?(0,c.jsx)("span",{children:"null"}):""+JSON.stringify(t);if("reflection"===t.type){const e=t.declaration;if("Type literal"===e.kindString&&e.signatures&&!e.children){const t=re(e.signatures)??e.signatures[0],r=t.parameters||[];return(0,c.jsx)(c.Fragment,{children:(0,c.jsxs)("span",{children:[i?"(":"","(",r.map(((e,t)=>(0,c.jsxs)("span",{children:[t>0?",":"",e.name,": ",(0,c.jsx)(_,{type:e.type,references:n})]},t))),") => ",(0,c.jsx)(_,{type:t.type,references:n}),i?")":""]})})}return"object"}if("intersection"===t.type){return t.types.map(((e,t)=>(0,c.jsxs)(c.Fragment,{children:[t>0?" & ":"",(0,c.jsx)(_,{type:e,references:n,isInUnionOrArray:!0})]})))}return""+JSON.stringify(t)}function J(e){return"intrinsic"===e.type?e.name:e.name?"Promise"===e.name&&"Promise"===e.qualifiedName&&e.typeArguments&&1===e.typeArguments.length?`Promise&lt;${J(e.typeArguments[0])}&gt;`:e.name:"union"===e.type?`(${e.types.map((e=>J(e))).join(" | ")})`:"array"===e.type?`${J(e.elementType)}[]`:"literal"===e.type?"string"==typeof e.value?`"${e.value}"`:"number"==typeof e.value?String(e.value):"boolean"==typeof e.value?e.value?"true":"false":""+JSON.stringify(e):"reflection"===e.type?"object":"missing!: "+JSON.stringify(e)}function G(e){return e&&U(e.type)}function U(e){return e&&"reflection"===e.type&&e.declaration&&e.declaration.signatures&&e.declaration.signatures.some((e=>"Call signature"===e.kindString))}function H(e){return e&&e.type&&"intersection"===e.type.type&&e.type.types.some((e=>U(e)))}function B(e){return e&&"Call signature"===e.kindString}function K(e,t){const n=e.comment?.tags?.find((e=>e.tag===t));return n?n.text.trim():null}function ee(e){if(e)for(let t of e){const e=K(t,"docname");if(e)return e.trim()}return null}function te(e){if("Method"===e.kindString){let t=ee(e.signatures);if(t)return t}else if(G(e)){const t=e?.type?.declaration,n=t?.signatures;let r=ee(n);if(r)return r}else if(H(e)){const t=e.type.types;for(let e of t)if(U(e)){let t=ee(e.declaration.signatures);if(t)return t}}else if(B(e)){let t=ee([e]);if(t)return t}return K(t=e,"docname")||t.name;var t}function ne(e){const t=K(e,"docid");if(t)return t;const n=function(e,t){let n=[];return j(e,((e,r,i)=>{"comment"===i&&n.push(...e.tags.filter((e=>e.tag===t)))})),n}(e,"docid");return n.length>0?n[0].text.trim():te(e)}function re(e){for(let t of e){if(K(t,"docgroup"))return t}return null}},1278:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>g,contentTitle:()=>h,default:()=>y,frontMatter:()=>u,metadata:()=>p,toc:()=>f});var r=n(6106),i=n(1875),a=n(979);n(2304);const o=JSON.parse('{"id":167,"name":"Rotation","kind":128,"kindString":"Class","flags":{},"comment":{"shortText":"Defines a class that can represent geometric rotations."},"children":[{"id":186,"name":"constructor","kind":512,"kindString":"Constructor","flags":{},"sources":[{"fileName":"src/aux-common/math/Rotation.ts","line":47,"character":4}],"signatures":[{"id":187,"name":"new Rotation","kind":16384,"kindString":"Constructor signature","flags":{},"comment":{"shortText":"Creates a new rotation using the given parameters.","tags":[{"tag":"example","text":"Create a rotation from an axis and angle.\\nconst rotation = new Rotation({\\n    axis: new Vector3(0, 0, 1),\\n    angle: Math.PI / 2\\n}); // 90 degree rotation around Z axis\\n"},{"tag":"example","text":"Create a rotation from two vectors.\\nconst rotation = new Rotation({\\n    from: new Vector3(1, 0, 0),\\n    to: new Vector3(0, 1, 0)\\n}); // Rotation that rotates (1, 0, 0) to (0, 1, 0)\\n"},{"tag":"example","text":"Create a rotation that looks along the X axis.\\nconst rotation = new Rotation({\\n    direction: new Vector3(1, 0, 0),\\n    upwards: new Vector3(0, 0, 1),\\n    errorHandling: \'nudge\'\\n});\\n"},{"tag":"example","text":"Tilt this bot forwards in the home dimension.\\ntags.homeRotation = new Rotation({\\n    axis: new Vector3(1, 0, 0),\\n    angle: Math.PI / 6 // 30 degrees\\n});\\n"}]},"parameters":[{"id":188,"name":"rotation","kind":32768,"kindString":"Parameter","flags":{"isOptional":true},"comment":{"shortText":"The information that should be used to construct the rotation.\\n"},"type":{"type":"union","types":[{"type":"reference","id":135,"name":"Quaternion"},{"type":"reference","id":213,"name":"AxisAndAngle"},{"type":"reference","id":210,"name":"FromToRotation"},{"type":"reference","id":233,"name":"LookRotation"},{"type":"reference","id":226,"name":"QuaternionRotation"},{"type":"reference","id":224,"name":"SequenceRotation"},{"type":"reference","id":216,"name":"EulerAnglesRotation"}]}}],"type":{"type":"reference","id":167,"name":"Rotation"}}]},{"id":189,"name":"_q","kind":1024,"kindString":"Property","flags":{"isPrivate":true},"sources":[{"fileName":"src/aux-common/math/Rotation.ts","line":9,"character":12}],"type":{"type":"reference","id":135,"name":"Quaternion"}},{"id":190,"name":"quaternion","kind":262144,"kindString":"Accessor","flags":{},"sources":[{"fileName":"src/aux-common/math/Rotation.ts","line":14,"character":8}],"getSignature":[{"id":191,"name":"quaternion","kind":524288,"kindString":"Get signature","flags":{},"comment":{"shortText":"The quaternion that this rotation uses."},"type":{"type":"reference","id":135,"name":"Quaternion"}}]},{"id":203,"name":"axisAndAngle","kind":2048,"kindString":"Method","flags":{},"sources":[{"fileName":"src/aux-common/math/Rotation.ts","line":403,"character":4}],"signatures":[{"id":204,"name":"axisAndAngle","kind":4096,"kindString":"Call signature","flags":{},"comment":{"shortText":"Gets the axis and angle that this rotation rotates around."},"type":{"type":"reference","id":213,"name":"AxisAndAngle"}}]},{"id":198,"name":"combineWith","kind":2048,"kindString":"Method","flags":{},"sources":[{"fileName":"src/aux-common/math/Rotation.ts","line":378,"character":4}],"signatures":[{"id":199,"name":"combineWith","kind":4096,"kindString":"Call signature","flags":{},"comment":{"shortText":"Combines this rotation with the other rotation and returns a new rotation that represents the combination of the two.","tags":[{"tag":"example","text":"Combine two rotations together.\\nconst first = new Rotation({\\n    axis: new Vector3(1, 0, 0),\\n    angle: Math.PI / 4\\n}); // 45 degree rotation around X axis\\nconst second = new Rotation({\\n    axis: new Vector3(1, 0, 0),\\n    angle: Math.PI / 4\\n}); // 45 degree rotation around X axis\\n\\nconst third = first.combineWith(second); // 90 degree rotation around X\\n\\nos.toast(third);\\n"}]},"parameters":[{"id":200,"name":"other","kind":32768,"kindString":"Parameter","flags":{},"comment":{"shortText":"The other rotation.\\n"},"type":{"type":"reference","id":167,"name":"Rotation"}}],"type":{"type":"reference","id":167,"name":"Rotation"}}]},{"id":205,"name":"equals","kind":2048,"kindString":"Method","flags":{},"sources":[{"fileName":"src/aux-common/math/Rotation.ts","line":421,"character":4}],"signatures":[{"id":206,"name":"equals","kind":4096,"kindString":"Call signature","flags":{},"comment":{"shortText":"Determines if this rotation equals the other rotation."},"parameters":[{"id":207,"name":"other","kind":32768,"kindString":"Parameter","flags":{},"comment":{"shortText":"The rotation to check.\\n"},"type":{"type":"reference","id":167,"name":"Rotation"}}],"type":{"type":"intrinsic","name":"boolean"}}]},{"id":201,"name":"invert","kind":2048,"kindString":"Method","flags":{},"sources":[{"fileName":"src/aux-common/math/Rotation.ts","line":396,"character":4}],"signatures":[{"id":202,"name":"invert","kind":4096,"kindString":"Call signature","flags":{},"comment":{"shortText":"Calculates the inverse rotation of this rotation and returns a new rotation with the result.","tags":[{"tag":"example","text":"Calculate the inverse of a rotation.\\nconst first = new Rotation({\\n    axis: new Vector3(1, 0, 0),\\n    angle: Math.PI / 4\\n}); // 45 degree rotation around X axis\\nconst inverse = first.inverse();\\n\\nconst result = first.combineWith(inverse);\\n\\nos.toast(result);\\n"}]},"type":{"type":"reference","id":167,"name":"Rotation"}}]},{"id":195,"name":"rotateVector2","kind":2048,"kindString":"Method","flags":{},"sources":[{"fileName":"src/aux-common/math/Rotation.ts","line":356,"character":4}],"signatures":[{"id":196,"name":"rotateVector2","kind":4096,"kindString":"Call signature","flags":{},"comment":{"shortText":"Rotates the given Vector2 by this quaternion and returns a new vector containing the result.\\nNote that rotations around any other axis than (0, 0, 1) or (0, 0, -1) can produce results that contain a Z component.","tags":[{"tag":"example","text":"Apply a rotation to a Vector2 object.\\nconst rotation = new Rotation({\\n    axis: new Vector3(1, 0, 0),\\n    angle: Math.PI / 4\\n}); // 45 degree rotation around X axis\\n\\nconst point = new Vector2(1, 2);\\nconst rotated = rotation.rotateVector2(point);\\nos.toast(rotated);\\n"}]},"parameters":[{"id":197,"name":"vector","kind":32768,"kindString":"Parameter","flags":{},"comment":{"shortText":"The 2D vector that should be rotated.\\n"},"type":{"type":"reference","id":1,"name":"Vector2"}}],"type":{"type":"reference","id":58,"name":"Vector3"}}]},{"id":192,"name":"rotateVector3","kind":2048,"kindString":"Method","flags":{},"sources":[{"fileName":"src/aux-common/math/Rotation.ts","line":310,"character":4}],"signatures":[{"id":193,"name":"rotateVector3","kind":4096,"kindString":"Call signature","flags":{},"comment":{"shortText":"Rotates the given Vector3 by this quaternion and returns a new vector containing the result.","tags":[{"tag":"example","text":"Apply a rotation to a Vector3 object.\\nconst rotation = new Rotation({\\n    axis: new Vector3(1, 0, 0),\\n    angle: Math.PI / 4\\n}); // 45 degree rotation around X axis\\n\\nconst point = new Vector3(1, 2, 0);\\nconst rotated = rotation.rotateVector3(point);\\nos.toast(rotated);\\n"}]},"parameters":[{"id":194,"name":"vector","kind":32768,"kindString":"Parameter","flags":{},"comment":{"shortText":"The 3D vector that should be rotated.\\n"},"type":{"type":"reference","id":58,"name":"Vector3"}}],"type":{"type":"reference","id":58,"name":"Vector3"}}]},{"id":208,"name":"toString","kind":2048,"kindString":"Method","flags":{},"sources":[{"fileName":"src/aux-common/math/Rotation.ts","line":437,"character":4}],"signatures":[{"id":209,"name":"toString","kind":4096,"kindString":"Call signature","flags":{},"comment":{"shortText":"Converts this rotation to a human-readable string representation.","tags":[{"tag":"example","text":"Get a string of a rotation.\\nconst myRotation = new Rotation({\\n    axis: new Vector3(1, 0, 0),\\n    angle: Math.PI / 4\\n}); // 45 degree rotation around X axis\\nconst rotationString = myRotation.toString();\\n\\nos.toast(\'My Rotation: \' + rotationString);\\n"}]},"type":{"type":"intrinsic","name":"string"}}]},{"id":177,"name":"angleBetween","kind":2048,"kindString":"Method","flags":{"isStatic":true},"sources":[{"fileName":"src/aux-common/math/Rotation.ts","line":241,"character":11}],"signatures":[{"id":178,"name":"angleBetween","kind":4096,"kindString":"Call signature","flags":{},"comment":{"shortText":"Determines the angle between the two given quaternions and returns the result in radians."},"parameters":[{"id":179,"name":"first","kind":32768,"kindString":"Parameter","flags":{},"comment":{"shortText":"The first quaternion. Must be a quaterion that represents a rotation"},"type":{"type":"reference","id":167,"name":"Rotation"}},{"id":180,"name":"second","kind":32768,"kindString":"Parameter","flags":{},"comment":{"shortText":"The second quaternion.\\n"},"type":{"type":"reference","id":167,"name":"Rotation"}}],"type":{"type":"intrinsic","name":"number"}}]},{"id":181,"name":"interpolate","kind":2048,"kindString":"Method","flags":{"isStatic":true},"sources":[{"fileName":"src/aux-common/math/Rotation.ts","line":253,"character":11}],"signatures":[{"id":182,"name":"interpolate","kind":4096,"kindString":"Call signature","flags":{},"comment":{"shortText":"Constructs a new rotation that is the spherical linear interpolation between the given first and second rotations.\\nThe degree that the result is interpolated is determined by the given amount parameter."},"parameters":[{"id":183,"name":"first","kind":32768,"kindString":"Parameter","flags":{},"comment":{"shortText":"The first rotation."},"type":{"type":"reference","id":167,"name":"Rotation"}},{"id":184,"name":"second","kind":32768,"kindString":"Parameter","flags":{},"comment":{"shortText":"The second rotation."},"type":{"type":"reference","id":167,"name":"Rotation"}},{"id":185,"name":"amount","kind":32768,"kindString":"Parameter","flags":{},"comment":{"shortText":"The amount that the resulting rotation should be interpolated between the first and second rotations. Values near 0 indicate rotations close to the first and values near 1 indicate rotations close to the second.\\n"},"type":{"type":"intrinsic","name":"number"}}],"type":{"type":"reference","id":167,"name":"Rotation"}}]},{"id":168,"name":"quaternionFromAxisAndAngle","kind":2048,"kindString":"Method","flags":{"isStatic":true},"sources":[{"fileName":"src/aux-common/math/Rotation.ts","line":126,"character":11}],"signatures":[{"id":169,"name":"quaternionFromAxisAndAngle","kind":4096,"kindString":"Call signature","flags":{},"comment":{"shortText":"Constructs a new Quaternion from the given axis and angle."},"parameters":[{"id":170,"name":"axisAndAngle","kind":32768,"kindString":"Parameter","flags":{},"comment":{"shortText":"The object that contains the axis and angle values.\\n"},"type":{"type":"reference","id":213,"name":"AxisAndAngle"}}],"type":{"type":"reference","id":135,"name":"Quaternion"}}]},{"id":171,"name":"quaternionFromTo","kind":2048,"kindString":"Method","flags":{"isStatic":true},"sources":[{"fileName":"src/aux-common/math/Rotation.ts","line":143,"character":11}],"signatures":[{"id":172,"name":"quaternionFromTo","kind":4096,"kindString":"Call signature","flags":{},"comment":{"shortText":"Constructs a new Quaternion from the given from/to rotation.\\nThis is equivalent to calculating the cross product and angle between the two vectors and constructing an axis/angle quaternion."},"parameters":[{"id":173,"name":"fromToRotation","kind":32768,"kindString":"Parameter","flags":{},"comment":{"shortText":"The object that contains the from and to values.\\n"},"type":{"type":"reference","id":210,"name":"FromToRotation"}}],"type":{"type":"reference","id":135,"name":"Quaternion"}}]},{"id":174,"name":"quaternionLook","kind":2048,"kindString":"Method","flags":{"isStatic":true},"sources":[{"fileName":"src/aux-common/math/Rotation.ts","line":160,"character":11}],"signatures":[{"id":175,"name":"quaternionLook","kind":4096,"kindString":"Call signature","flags":{},"comment":{"shortText":"Constructs a new Quaternion from the given look rotation."},"parameters":[{"id":176,"name":"look","kind":32768,"kindString":"Parameter","flags":{},"comment":{"shortText":"The object that contains the look rotation values.\\n"},"type":{"type":"reference","id":233,"name":"LookRotation"}}],"type":{"type":"reference","id":135,"name":"Quaternion"}}]}],"groups":[{"title":"Constructors","kind":512,"children":[186]},{"title":"Properties","kind":1024,"children":[189]},{"title":"Accessors","kind":262144,"children":[190]},{"title":"Methods","kind":2048,"children":[203,198,205,201,195,192,208,177,181,168,171,174]}],"sources":[{"fileName":"src/aux-common/math/Rotation.ts","line":8,"character":13}]}'),s=JSON.parse('{"id":213,"name":"AxisAndAngle","kind":256,"kindString":"Interface","flags":{},"comment":{"shortText":"Defines an interface that represents an Axis and Angle pair."},"children":[{"id":215,"name":"angle","kind":1024,"kindString":"Property","flags":{},"comment":{"shortText":"The number of radians that should be rotated around the axis."},"sources":[{"fileName":"src/aux-common/math/Rotation.ts","line":475,"character":4}],"type":{"type":"intrinsic","name":"number"}},{"id":214,"name":"axis","kind":1024,"kindString":"Property","flags":{},"comment":{"shortText":"The axis about which the angle should rotate around."},"sources":[{"fileName":"src/aux-common/math/Rotation.ts","line":470,"character":4}],"type":{"type":"reference","id":58,"name":"Vector3"}}],"groups":[{"title":"Properties","kind":1024,"children":[215,214]}],"sources":[{"fileName":"src/aux-common/math/Rotation.ts","line":466,"character":17}]}'),c=JSON.parse('{"id":210,"name":"FromToRotation","kind":256,"kindString":"Interface","flags":{},"comment":{"shortText":"Defines an interface that represents a from/to rotation.\\nThat is, a rotation that is able to rotate a vector from the given vector direction to the given vector direction."},"children":[{"id":211,"name":"from","kind":1024,"kindString":"Property","flags":{},"comment":{"shortText":"The direction that the rotation should rotate from."},"sources":[{"fileName":"src/aux-common/math/Rotation.ts","line":455,"character":4}],"type":{"type":"reference","id":58,"name":"Vector3"}},{"id":212,"name":"to","kind":1024,"kindString":"Property","flags":{},"comment":{"shortText":"The direction that the rotation should rotate to."},"sources":[{"fileName":"src/aux-common/math/Rotation.ts","line":460,"character":4}],"type":{"type":"reference","id":58,"name":"Vector3"}}],"groups":[{"title":"Properties","kind":1024,"children":[211,212]}],"sources":[{"fileName":"src/aux-common/math/Rotation.ts","line":451,"character":17}]}'),l=JSON.parse('{"id":224,"name":"SequenceRotation","kind":256,"kindString":"Interface","flags":{},"comment":{"shortText":"Defines an interface that represents a sequence of rotations."},"children":[{"id":225,"name":"sequence","kind":1024,"kindString":"Property","flags":{},"comment":{"shortText":"The sequence of successive rotations."},"sources":[{"fileName":"src/aux-common/math/Rotation.ts","line":519,"character":4}],"type":{"type":"array","elementType":{"type":"reference","id":167,"name":"Rotation"}}}],"groups":[{"title":"Properties","kind":1024,"children":[225]}],"sources":[{"fileName":"src/aux-common/math/Rotation.ts","line":515,"character":17}]}'),d=JSON.parse('{"id":135,"name":"Quaternion","kind":128,"kindString":"Class","flags":{},"comment":{"shortText":"Defines a class that represents a Quaternion. That is, a representation of a 3D rotation.","text":"Quaternions are a mathematical representation of 3D transformations and are commonly used to calculate and apply rotations to 3D points.\\nThey work by defining a quaterion such that q = w + x*i + y*j + z*k, where w, x, y, and z are real numbers and i, j, and k are imaginary numbers.\\nThe basics of this is that x, y, and z define a vector that represents the rotation axis, and w defines an angle around which the rotation occurs.\\nHowever, because i, j, and k are included we can keep x, y, and z from incorrectly interacting with each other and so avoid common pitfalls like Gimbal lock.\\n\\nOne little known feature of quaternions is that they can also represent reflections and also scale.\\nThis is because there are two different ways to apply a quaternion to a 3D point:\\n\\n- quaterion * point * inverse(quaterion)\\n\\nThis formula rotates and scales the point quaternion. The rotation occurs around the axis specified by the quaternion X, Y, and Z values.\\nAdditionally, the point will be scaled by the length of the quaternion. (i.e. sqrt( x^2 + y^2 + z^2 + w^2 ))\\nThis is why quaternions that are used to represent only rotations must be normalized.\\n\\n- quaternion * point * quaternion\\n\\nThis formula reflects scales the point by the quaternion. The reflection occurs across the axis specified by the quaternion X, Y, and Z values.\\nAdditionally, the point will be scaled by the length of the quaternion. (i.e. sqrt( x^2 + y^2 + z^2 + w^2 ))\\n"},"children":[{"id":136,"name":"constructor","kind":512,"kindString":"Constructor","flags":{},"sources":[{"fileName":"src/aux-common/math/Quaternion.ts","line":51,"character":4}],"signatures":[{"id":137,"name":"new Quaternion","kind":16384,"kindString":"Constructor signature","flags":{},"comment":{"shortText":"Creates a new Quaternion with the given values."},"parameters":[{"id":138,"name":"x","kind":32768,"kindString":"Parameter","flags":{},"comment":{"shortText":"The X value."},"type":{"type":"intrinsic","name":"number"},"defaultValue":"0"},{"id":139,"name":"y","kind":32768,"kindString":"Parameter","flags":{},"comment":{"shortText":"The Y value."},"type":{"type":"intrinsic","name":"number"},"defaultValue":"0"},{"id":140,"name":"z","kind":32768,"kindString":"Parameter","flags":{},"comment":{"shortText":"The Z value."},"type":{"type":"intrinsic","name":"number"},"defaultValue":"0"},{"id":141,"name":"w","kind":32768,"kindString":"Parameter","flags":{},"comment":{"shortText":"The W value.\\n"},"type":{"type":"intrinsic","name":"number"},"defaultValue":"1"}],"type":{"type":"reference","id":135,"name":"Quaternion"}}]},{"id":145,"name":"w","kind":1024,"kindString":"Property","flags":{},"comment":{"shortText":"The W value of the quaternion."},"sources":[{"fileName":"src/aux-common/math/Quaternion.ts","line":42,"character":4}],"type":{"type":"intrinsic","name":"number"}},{"id":142,"name":"x","kind":1024,"kindString":"Property","flags":{},"comment":{"shortText":"The X value of the quaternion."},"sources":[{"fileName":"src/aux-common/math/Quaternion.ts","line":27,"character":4}],"type":{"type":"intrinsic","name":"number"}},{"id":143,"name":"y","kind":1024,"kindString":"Property","flags":{},"comment":{"shortText":"The Y value of the quaternion."},"sources":[{"fileName":"src/aux-common/math/Quaternion.ts","line":32,"character":4}],"type":{"type":"intrinsic","name":"number"}},{"id":144,"name":"z","kind":1024,"kindString":"Property","flags":{},"comment":{"shortText":"The Z value of the quaternion."},"sources":[{"fileName":"src/aux-common/math/Quaternion.ts","line":37,"character":4}],"type":{"type":"intrinsic","name":"number"}},{"id":159,"name":"equals","kind":2048,"kindString":"Method","flags":{},"sources":[{"fileName":"src/aux-common/math/Quaternion.ts","line":154,"character":4}],"signatures":[{"id":160,"name":"equals","kind":4096,"kindString":"Call signature","flags":{},"comment":{"shortText":"Determines if this quaternion equals the other quaternion."},"parameters":[{"id":161,"name":"other","kind":32768,"kindString":"Parameter","flags":{},"comment":{"shortText":"The other quaternion to apply.\\n"},"type":{"type":"reference","id":135,"name":"Quaternion"}}],"type":{"type":"intrinsic","name":"boolean"}}]},{"id":149,"name":"invert","kind":2048,"kindString":"Method","flags":{},"sources":[{"fileName":"src/aux-common/math/Quaternion.ts","line":100,"character":4}],"signatures":[{"id":150,"name":"invert","kind":4096,"kindString":"Call signature","flags":{},"comment":{"shortText":"Calculates the conjugate of this quaternion and returns the result.\\nThe conjugate (or inverse) of a quaternion is similar to negating a number.\\nWhen you multiply a quaternion by its conjugate, the result is the identity quaternion."},"type":{"type":"reference","id":135,"name":"Quaternion"}}]},{"id":151,"name":"length","kind":2048,"kindString":"Method","flags":{},"sources":[{"fileName":"src/aux-common/math/Quaternion.ts","line":107,"character":4}],"signatures":[{"id":152,"name":"length","kind":4096,"kindString":"Call signature","flags":{},"comment":{"shortText":"Gets the length of this vector. That is, the pathagorean theorem applied to X, Y, Z, and W."},"type":{"type":"intrinsic","name":"number"}}]},{"id":146,"name":"multiply","kind":2048,"kindString":"Method","flags":{},"sources":[{"fileName":"src/aux-common/math/Quaternion.ts","line":70,"character":4}],"signatures":[{"id":147,"name":"multiply","kind":4096,"kindString":"Call signature","flags":{},"comment":{"shortText":"Multiplies this quaternion by the other quaternion and returns the result.\\nIn quaternion math, multiplication can be used to combine quaternions together,\\nhowever unlike regular multiplication quaternion multiplication is order dependent.","text":"Which frame of reference you want to use depends on which order you use.\\nFor example, q2.multiply(q1) starts with the identity, applies q1 to it, and then applies q2 to that.\\nWhereas, q1.multiply(q2) starts with the identity, applies q2 to it, and then applies q1 to that.\\n"},"parameters":[{"id":148,"name":"other","kind":32768,"kindString":"Parameter","flags":{},"comment":{"shortText":"The other quaternion.\\n"},"type":{"type":"reference","id":135,"name":"Quaternion"}}],"type":{"type":"reference","id":135,"name":"Quaternion"}}]},{"id":155,"name":"normalize","kind":2048,"kindString":"Method","flags":{},"sources":[{"fileName":"src/aux-common/math/Quaternion.ts","line":136,"character":4}],"signatures":[{"id":156,"name":"normalize","kind":4096,"kindString":"Call signature","flags":{},"comment":{"shortText":"Calculates the normalized version of this quaternion and returns it.\\nA normalized quaternion is a quaternion whose length equals 1.","text":"Normalizing a quaternion preserves its rotation/reflection while making the length (i.e. scale) of it 1.\\n"},"type":{"type":"reference","id":135,"name":"Quaternion"}}]},{"id":153,"name":"squareLength","kind":2048,"kindString":"Method","flags":{},"sources":[{"fileName":"src/aux-common/math/Quaternion.ts","line":121,"character":4}],"signatures":[{"id":154,"name":"squareLength","kind":4096,"kindString":"Call signature","flags":{},"comment":{"shortText":"Calculates the square length of this quaternion and returns the result.\\nThis is equivalent to length^2, but it is faster to calculate than length because it doesn\'t require\\ncalculating a square root."},"type":{"type":"intrinsic","name":"number"}}]},{"id":157,"name":"toString","kind":2048,"kindString":"Method","flags":{},"sources":[{"fileName":"src/aux-common/math/Quaternion.ts","line":146,"character":4}],"signatures":[{"id":158,"name":"toString","kind":4096,"kindString":"Call signature","flags":{},"type":{"type":"intrinsic","name":"string"}}]}],"groups":[{"title":"Constructors","kind":512,"children":[136]},{"title":"Properties","kind":1024,"children":[145,142,143,144]},{"title":"Methods","kind":2048,"children":[159,149,151,146,155,153,157]}],"sources":[{"fileName":"src/aux-common/math/Quaternion.ts","line":23,"character":13}]}');var m=n(4183);const u={id:"rotations",title:"Rotations",sidebar_label:"Rotations",description:"Rotations help represent orientation."},h=void 0,p={id:"math/rotations",title:"Rotations",description:"Rotations help represent orientation.",source:"@site/versioned_docs/version-3.1.36/math/rotations.mdx",sourceDirName:"math",slug:"/math/rotations",permalink:"/3.1.36/math/rotations",draft:!1,unlisted:!1,editUrl:"https://github.com/casual-simulation/casualos/tree/develop/docs/versioned_docs/version-3.1.36/math/rotations.mdx",tags:[],version:"3.1.36",frontMatter:{id:"rotations",title:"Rotations",sidebar_label:"Rotations",description:"Rotations help represent orientation."},sidebar:"docs",previous:{title:"Vectors",permalink:"/3.1.36/math/vectors"}},g={},f=[{value:"Introduction",id:"introduction",level:2},{value:"Rotation",id:"rotation",level:2},...(0,a.yx)(o),{value:"Quaternion",id:"quaternion",level:2},...(0,a.yx)(d),{value:"AxisAndAngle",id:"axisandangle",level:2},...(0,a.yx)(s),{value:"FromToRotation",id:"fromtorotation",level:2},...(0,a.yx)(c),{value:"SequenceRotation",id:"sequencerotation",level:2},...(0,a.yx)(l),{value:"EulerAnglesRotation",id:"euleranglesrotation",level:2},{value:"QuaternionRotation",id:"quaternionrotation",level:2},{value:"LookRotation",id:"lookrotation",level:2}];function x(e){const t={a:"a",code:"code",p:"p",pre:"pre",...(0,i.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(m.A,{as:"h2",id:"introduction",children:"Introduction"}),"\n",(0,r.jsxs)(t.p,{children:["In CasualOS, Rotations are useful objects that represent 3D orientations and changes in orientation.\nMathematically, CasualOS uses ",(0,r.jsx)(t.a,{href:"https://euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/",children:"Quaternions"})," to represent rotations."]}),"\n",(0,r.jsxs)(t.p,{children:["Practically, CasualOS allows constructing rotations from Euler angles (X, Y, and Z angles) as well as from an arbitrary 3D axis and angle or even a sequence of rotations.\nWhen saved to tags, rotations are stored as ",(0,r.jsx)(t.a,{href:"/tags#rotation-tags",children:"rotation tags"}),"."]}),"\n",(0,r.jsx)(m.A,{as:"h2",id:"rotation",children:"Rotation"}),"\n",(0,r.jsxs)(t.p,{children:[(0,r.jsx)(t.code,{children:"Rotation"})," is a class that is able to represent 2D positions and directions."]}),"\n",(0,r.jsx)(a.Ey,{reflection:o}),"\n",(0,r.jsx)(m.A,{as:"h2",id:"quaternion",children:"Quaternion"}),"\n",(0,r.jsxs)(t.p,{children:[(0,r.jsx)(t.code,{children:"Quaternion"})," is a class that represents a 3D rotation by using ",(0,r.jsx)(t.a,{href:"https://en.wikipedia.org/wiki/Quaternion",children:"Quaternion math"}),"."]}),"\n",(0,r.jsx)(a.Ey,{reflection:d}),"\n",(0,r.jsx)(m.A,{as:"h2",id:"axisandangle",children:"AxisAndAngle"}),"\n",(0,r.jsxs)(t.p,{children:[(0,r.jsx)(t.code,{children:"AxisAndAngle"})," is a type that represents a 3D rotation around an arbitrary 3D axis."]}),"\n",(0,r.jsx)(t.p,{children:"It should be an object that contains the following properties:"}),"\n",(0,r.jsx)(a.Ey,{reflection:s}),"\n",(0,r.jsx)(m.A,{as:"h2",id:"fromtorotation",children:"FromToRotation"}),"\n",(0,r.jsxs)(t.p,{children:[(0,r.jsx)(t.code,{children:"FromToRotation"})," is a type that represents a 3D rotation that rotates one vector into another vector."]}),"\n",(0,r.jsx)(t.p,{children:"It should be an object that contains the following properties:"}),"\n",(0,r.jsx)(a.Ey,{reflection:c}),"\n",(0,r.jsx)(m.A,{as:"h2",id:"sequencerotation",children:"SequenceRotation"}),"\n",(0,r.jsxs)(t.p,{children:[(0,r.jsx)(t.code,{children:"SequenceRotation"})," is a type that represents a 3D rotation by combining several rotations together."]}),"\n",(0,r.jsx)(t.p,{children:"It should be an object that contains the following properties:"}),"\n",(0,r.jsx)(a.Ey,{reflection:l}),"\n",(0,r.jsx)(m.A,{as:"h2",id:"euleranglesrotation",children:"EulerAnglesRotation"}),"\n",(0,r.jsxs)(t.p,{children:[(0,r.jsx)(t.code,{children:"EulerAnglesRotation"})," is a type that represents a 3D rotation using separate X, Y, and Z values."]}),"\n",(0,r.jsx)(t.p,{children:"It should be an object that contains the following properties:"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-typescript",children:"const eulerAnglesRotation: {\n    euler: {\n        /**\n         * The amount to rotate around the X axis.\n         */\n        x: number;\n\n        /**\n         * The amount to rotate around the Y axis.\n         */\n        y: number;\n\n        /**\n         * The amount to rotate around the Z axis.\n         */\n        z: number;\n\n        /**\n         * The order that the rotations should be applied in.\n         * Defaults to XYZ\n         */\n        order?: string;\n\n        /**\n         * Whether the euler angles are extrinsic.\n         * Defaults to false.\n         */\n        extrinsic?: boolean;\n    };\n}\n"})}),"\n",(0,r.jsx)(m.A,{as:"h2",id:"quaternionrotation",children:"QuaternionRotation"}),"\n",(0,r.jsxs)(t.p,{children:[(0,r.jsx)(t.code,{children:"QuaternionRotation"})," is a type that represents a 3D rotation by using a Quaternion."]}),"\n",(0,r.jsx)(t.p,{children:"It should be an object that contains the following properties:"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-typescript",children:"export interface QuaternionRotation {\n    quaternion: { x: number; y: number; z: number; w: number };\n}\n"})}),"\n",(0,r.jsx)(m.A,{as:"h2",id:"lookrotation",children:"LookRotation"}),"\n",(0,r.jsxs)(t.p,{children:[(0,r.jsx)(t.code,{children:"LookRotation"})," is a type that represents a 3D rotation by using a direction and upwards vector.\nThe resulting rotations are able to orient a bot such that the rear bot face is looking along the direction and the top bot face is looking in the same direction as the upwards vector."]}),"\n",(0,r.jsx)(t.p,{children:"It should be an object that contains the following properties:"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-typescript",children:"export interface LookRotation {\n    /**\n     * The direction that (0, 1, 0) should be pointing along after the rotation is applied.\n     */\n    direction: Vector3;\n\n    /**\n     * The direction that the upward axis should be pointing along after the rotation is applied.\n     * If the direction and upwards vectors are not perpendicular, then the direction will be prioritized and the angle between\n     * upwards and the resulting upwards vector will be minimized.\n     *\n     * If direction and upwards are perpendicular, then applying the rotation to (0, 0, 1) will give the upwards vector.\n     */\n    upwards: Vector3;\n\n    /**\n     * How errors with the direction and upwards vectors should be handled.\n     * If the direction and upwards vectors are parallel or perpendicular, then it is not possible to create a rotation\n     * that looks along the direction and uses the upwards vector. The upwards vector is essentially useless in this scenario\n     * and as a result there are an infinite number of possible valid rotations that look along direction vector.\n     *\n     * This parameter provides two ways to handle this situation:\n     *\n     * - \"error\" indicates that an error should be thrown when this situation arises.\n     * - \"nudge\" indicates that the direction vector should be nudged by a miniscule amount in an arbitrary direction.\n     *           This causes the upwards and direction vectors to no longer be parallel, but it can also cause rotation bugs when the direction and upwards are the same.\n     */\n    errorHandling: 'error' | 'nudge';\n}\n"})})]})}function y(e={}){const{wrapper:t}={...(0,i.R)(),...e.components};return t?(0,r.jsx)(t,{...e,children:(0,r.jsx)(x,{...e})}):x(e)}},2304:(e,t,n)=>{var r=n(979);const i=["Rotation","AxisAndAngle","FromToRotation","SequenceRotation","EulerAnglesRotation","Quaternion"],a={Vector2:"math/vectors",Vector3:"math/vectors"};for(let o of i)a[o]="math/rotations";(0,r.H_)(a)}}]);