"use strict";(self.webpackChunkcasual_simulation=self.webpackChunkcasual_simulation||[]).push([[916],{3952:function(e,t,n){for(var r=n(3301),a={Vector2:"math/vectors",Vector3:"math/vectors"},o=0,i=["Rotation","AxisAndAngle","FromToRotation","SequenceRotation","EulerAnglesRotation","Quaternion"];o<i.length;o++){a[i[o]]="math/rotations"}(0,r.Op)(a)},3301:function(e,t,n){n.d(t,{zl:function(){return k},HE:function(){return v},Op:function(){return d}});var r=n(7639),a=n(7294),o=n(9649),i=n(5710),s=n(6486),l=n(1073),u=function(e){function t(t){var n;return(n=e.call(this,t)||this).state={hasError:!1},n}(0,l.Z)(t,e),t.getDerivedStateFromError=function(e){return{hasError:!0,error:e}};var n=t.prototype;return n.componentDidCatch=function(e,t){var n="["+this.props.reflection.name+"] "+e;if(!this.props.root)throw n;console.error(n)},n.render=function(){return this.state.hasError?a.createElement("h1",null,"[",this.props.reflection.name,"] ",this.state.error):this.props.children},t}(a.Component),c=n(4996),p=n(9960),m={};function d(e){m=e}var h=["first","second","third","fourth","fifth"];function g(e,t){return e.name+"-"+t.name}function f(e,t){var n,r=g(e,t);return{value:"<code>"+("Constructor"===t.kindString||"Method"===t.kindString?x(t.signatures[0]):"Accessor"===t.kindString?(n=t).name+": "+C(n.getSignature[0].type):function(e){return e.name+": "+C(e.type)}(t))+"</code>",id:r,level:3}}function v(e){var t=[],n=function(e){for(var t,n=[],a=[],o=[],i=(0,r.Z)(e);!(t=i()).done;){var s=t.value;s.flags.isPrivate||("Property"===s.kindString||"Accessor"===s.kindString?n.push(s):"Constructor"===s.kindString?a.push(s):"Method"===s.kindString&&o.push(s))}return{properties:n,constructors:a,methods:o}}(e.children),a=n.properties,o=n.constructors,i=n.methods;return a.length>0&&t.push.apply(t,a.map((function(t){return f(e,t)}))),o.length>0&&t.push.apply(t,o.map((function(t){return f(e,t)}))),i.length>0&&t.push.apply(t,i.map((function(t){return f(e,t)}))),t}function k(e){var t=e.reflection;if(!t)throw new Error("Unable to find "+e.name+"!");var n=function(e){return(0,s.sortBy)(e,(function(e){return"Property"===e.kindString||"Accessor"===e.kindString?0:"Constructor"===e.kindString?1:2})).filter((function(e){return!e.flags.isPrivate}))}(t.children);return a.createElement(u,{reflection:t,root:!0},a.createElement("div",{className:"api"},n.map((function(e){return a.createElement(b,{key:e.name,member:e,link:g(t,e)})}))))}function b(e){var t;return t="Property"===e.member.kindString?function(e){var t;return a.createElement("div",null,a.createElement(o.Z,{as:"h3",id:e.link},a.createElement("code",null,e.member.name,": ",a.createElement(S,{type:e.member.type}))),a.createElement("p",null,null==(t=e.member.comment)?void 0:t.shortText))}(e):"Constructor"===e.member.kindString||"Method"===e.member.kindString?function(e){return a.createElement("div",null,a.createElement(y,{func:e.member,sig:e.member.signatures[0],link:e.link}))}(e):"Accessor"===e.member.kindString?function(e){var t;return a.createElement("div",null,a.createElement(o.Z,{as:"h3",id:e.link},a.createElement("code",null,e.member.name,": ",a.createElement(S,{type:e.member.getSignature[0].type}))),a.createElement("p",null,null==(t=e.member.getSignature[0].comment)?void 0:t.shortText))}(e):"Not found "+e.member.kindString,a.createElement(u,{reflection:e.member},a.createElement("div",null,t))}function y(e){var t,n=e.func,r=e.sig,i=e.link,s=r.parameters||[];return a.createElement("div",null,a.createElement(o.Z,{as:"h3",id:i},a.createElement(E,{func:n,sig:r})),a.createElement("p",null,null==(t=r.comment)?void 0:t.shortText),s.length>0?a.createElement("div",null,s.map((function(e,t){return a.createElement(w,{key:e.name,param:e,index:t})}))):"",a.createElement(T,{member:r}))}function E(e){var t=e.func,n=e.sig,r=n.parameters||[];return a.createElement("code",null,(t.flags.isStatic?"static ":"")+n.name,"(",r.map((function(e,t){return a.createElement("span",{key:e.name},t>0?", ":"",e.name,": ",a.createElement(S,{type:e.type}))})),"): ",a.createElement(S,{type:n.type}))}function x(e){var t=e.parameters||[];return e.name+"("+t.map((function(e,t){return e.name})).join(", ")+"): "+C(e.type)}function w(e){var t=e.param,n=e.index;return a.createElement("p",null,"The ",a.createElement("strong",null,function(e){return h[e]}(n)," parameter")," is a ",a.createElement(S,{type:t.type})," and ",function(e){var t,n=null==(t=e.comment)?void 0:t.shortText;if(!n)throw'A description for "'+e.name+'" is not available.';(n=n.slice(0,1).toLowerCase()+n.slice(1)).startsWith("the")&&(n="is "+n);return n}(t))}function T(e){var t,n=e.member;if(null==(t=n.comment)||!t.tags)return"";var r=n.comment.tags.filter((function(e){return"example"===e.tag}));return r.length>0?a.createElement("div",null,a.createElement("h4",null,"Examples"),r.map((function(e,t){return a.createElement(R,{key:t,example:e})}))):""}function R(e){var t=e.example.text,n=t.indexOf("\n"),r=t.substring(0,n),o=t.substring(n+1);return a.createElement(i.Z,{language:"typescript",title:r.trim()},o.trim())}function S(e){var t=e.type;if("intrinsic"===t.type)return a.createElement("span",null,t.name);if(t.name){var n="#"+t.name.toLowerCase(),r=m[t.name];return r&&(n=(0,c.Z)(r)+n),a.createElement(p.Z,{href:n},t.name)}return"union"===t.type?a.createElement("span",null,t.types.map((function(e,t){return a.createElement(a.Fragment,{key:t},t>0?" | ":"",a.createElement(S,{type:e}))}))):"array"===t.type?a.createElement(a.Fragment,null,a.createElement(S,{type:t.elementType}),"[]"):""+JSON.stringify(t)}function C(e){return"intrinsic"===e.type||e.name?e.name:"union"===e.type?e.types.map((function(e){return C(e)})).join(" | "):"array"===e.type?C(e.elementType)+"[]":"missing!: "+JSON.stringify(e)}},2854:function(e,t,n){n.r(t),n.d(t,{assets:function(){return x},contentTitle:function(){return y},default:function(){return R},frontMatter:function(){return b},metadata:function(){return E},toc:function(){return w}});var r=n(3117),a=n(102),o=(n(7294),n(3905)),i=n(3301),s=(n(3952),n(6365)),l=n.n(s),u=n(3971),c=n.n(u),p=n(4932),m=n.n(p),d=n(4561),h=n.n(d),g=(n(2927),n(6070)),f=n.n(g),v=(n(3951),n(9649)),k=["components"],b={id:"rotations",title:"Rotations",sidebar_label:"Rotations",description:"Rotations help represent orientation."},y=void 0,E={unversionedId:"math/rotations",id:"math/rotations",title:"Rotations",description:"Rotations help represent orientation.",source:"@site/docs/math/rotations.mdx",sourceDirName:"math",slug:"/math/rotations",permalink:"/math/rotations",draft:!1,editUrl:"https://github.com/casual-simulation/casualos/tree/develop/docs/docs/math/rotations.mdx",tags:[],version:"current",frontMatter:{id:"rotations",title:"Rotations",sidebar_label:"Rotations",description:"Rotations help represent orientation."},sidebar:"docs",previous:{title:"Vectors",permalink:"/math/vectors"}},x={},w=[{value:"Introduction",id:"introduction",level:2},{value:"Rotation",id:"rotation",level:2}].concat((0,i.HE)(l()),[{value:"Quaternion",id:"quaternion",level:2}],(0,i.HE)(f()),[{value:"AxisAndAngle",id:"axisandangle",level:2}],(0,i.HE)(c()),[{value:"FromToRotation",id:"fromtorotation",level:2}],(0,i.HE)(m()),[{value:"SequenceRotation",id:"sequencerotation",level:2}],(0,i.HE)(h()),[{value:"EulerAnglesRotation",id:"euleranglesrotation",level:2},{value:"QuaternionRotation",id:"quaternionrotation",level:2},{value:"LookRotation",id:"lookrotation",level:2}]),T={toc:w};function R(e){var t=e.components,n=(0,a.Z)(e,k);return(0,o.kt)("wrapper",(0,r.Z)({},T,n,{components:t,mdxType:"MDXLayout"}),(0,o.kt)(v.Z,{as:"h2",id:"introduction",mdxType:"Heading"},"Introduction"),(0,o.kt)("p",null,"In CasualOS, Rotations are useful objects that represent 3D orientations and changes in orientation.\nMathematically, CasualOS uses ",(0,o.kt)("a",{parentName:"p",href:"https://euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/"},"Quaternions")," to represent rotations."),(0,o.kt)("p",null,"Practically, CasualOS allows constructing rotations from Euler angles (X, Y, and Z angles) as well as from an arbitrary 3D axis and angle or even a sequence of rotations.\nWhen saved to tags, rotations are stored as ",(0,o.kt)("a",{parentName:"p",href:"/tags#rotation-tags"},"rotation tags"),"."),(0,o.kt)(v.Z,{as:"h2",id:"rotation",mdxType:"Heading"},"Rotation"),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},"Rotation")," is a class that is able to represent 2D positions and directions."),(0,o.kt)(i.zl,{reflection:l(),mdxType:"ClassMembers"}),(0,o.kt)(v.Z,{as:"h2",id:"quaternion",mdxType:"Heading"},"Quaternion"),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},"Quaternion")," is a class that represents a 3D rotation by using ",(0,o.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Quaternion"},"Quaternion math"),"."),(0,o.kt)(i.zl,{reflection:f(),mdxType:"ClassMembers"}),(0,o.kt)(v.Z,{as:"h2",id:"axisandangle",mdxType:"Heading"},"AxisAndAngle"),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},"AxisAndAngle")," is a type that represents a 3D rotation around an arbitrary 3D axis."),(0,o.kt)("p",null,"It should be an object that contains the following properties:"),(0,o.kt)(i.zl,{reflection:c(),mdxType:"ClassMembers"}),(0,o.kt)(v.Z,{as:"h2",id:"fromtorotation",mdxType:"Heading"},"FromToRotation"),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},"FromToRotation")," is a type that represents a 3D rotation that rotates one vector into another vector."),(0,o.kt)("p",null,"It should be an object that contains the following properties:"),(0,o.kt)(i.zl,{reflection:m(),mdxType:"ClassMembers"}),(0,o.kt)(v.Z,{as:"h2",id:"sequencerotation",mdxType:"Heading"},"SequenceRotation"),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},"SequenceRotation")," is a type that represents a 3D rotation by combining several rotations together."),(0,o.kt)("p",null,"It should be an object that contains the following properties:"),(0,o.kt)(i.zl,{reflection:h(),mdxType:"ClassMembers"}),(0,o.kt)(v.Z,{as:"h2",id:"euleranglesrotation",mdxType:"Heading"},"EulerAnglesRotation"),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},"EulerAnglesRotation")," is a type that represents a 3D rotation using separate X, Y, and Z values."),(0,o.kt)("p",null,"It should be an object that contains the following properties:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-typescript"},"const eulerAnglesRotation: {\n    euler: {\n        /**\n         * The amount to rotate around the X axis.\n         */\n        x: number;\n\n        /**\n         * The amount to rotate around the Y axis.\n         */\n        y: number;\n\n        /**\n         * The amount to rotate around the Z axis.\n         */\n        z: number;\n\n        /**\n         * The order that the rotations should be applied in.\n         * Defaults to XYZ\n         */\n        order?: string;\n\n        /**\n         * Whether the euler angles are extrinsic.\n         * Defaults to false.\n         */\n        extrinsic?: boolean;\n    };\n}\n")),(0,o.kt)(v.Z,{as:"h2",id:"quaternionrotation",mdxType:"Heading"},"QuaternionRotation"),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},"QuaternionRotation")," is a type that represents a 3D rotation by using a Quaternion."),(0,o.kt)("p",null,"It should be an object that contains the following properties:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-typescript"},"export interface QuaternionRotation {\n    quaternion: { x: number; y: number; z: number; w: number };\n}\n")),(0,o.kt)(v.Z,{as:"h2",id:"lookrotation",mdxType:"Heading"},"LookRotation"),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},"LookRotation")," is a type that represents a 3D rotation by using a direction and upwards vector.\nThe resulting rotations are able to orient a bot such that the rear bot face is looking along the direction and the top bot face is looking in the same direction as the upwards vector."),(0,o.kt)("p",null,"It should be an object that contains the following properties:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-typescript"},"export interface LookRotation {\n    /**\n     * The direction that (0, 1, 0) should be pointing along after the rotation is applied.\n     */\n    direction: Vector3;\n\n    /**\n     * The direction that the upward axis should be pointing along after the rotation is applied.\n     * If the direction and upwards vectors are not perpendicular, then the direction will be prioritized and the angle between\n     * upwards and the resulting upwards vector will be minimized.\n     *\n     * If direction and upwards are perpendicular, then applying the rotation to (0, 0, 1) will give the upwards vector.\n     */\n    upwards: Vector3;\n\n    /**\n     * How errors with the direction and upwards vectors should be handled.\n     * If the direction and upwards vectors are parallel or perpendicular, then it is not possible to create a rotation\n     * that looks along the direction and uses the upwards vector. The upwards vector is essentially useless in this scenario\n     * and as a result there are an infinite number of possible valid rotations that look along direction vector.\n     *\n     * This parameter provides two ways to handle this situation:\n     *\n     * - \"error\" indicates that an error should be thrown when this situation arises.\n     * - \"nudge\" indicates that the direction vector should be nudged by a miniscule amount in an arbitrary direction.\n     *           This causes the upwards and direction vectors to no longer be parallel, but it can also cause rotation bugs when the direction and upwards are the same.\n     */\n    errorHandling: 'error' | 'nudge';\n}\n")))}R.isMDXComponent=!0}}]);